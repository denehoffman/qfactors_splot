#!/usr/bin/env python
"""
Usage: results <tsv>
       results <tsv> --plot

Options:
--plot  Compute pull distributions and plot
"""

from docopt import docopt
from pathlib import Path
import pandas as pd
from rich.table import Table
from sqfactors import console, BLUE, RED
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import to_rgb
import matplotlib as mpl

mpl.rcParams['figure.titlesize'] = 24
mpl.rcParams['axes.labelsize'] = 16


def zscore_to_colorstr(zscore: float, absmin_z: float, absmax_z: float) -> str:
    color_0 = '#FF2233'
    color_1 = '#1133BB'
    end_color = tuple(int(comp * 255) for comp in to_rgb(color_0))
    start_color = tuple(int(comp * 255) for comp in to_rgb(color_1))
    normed_zscore = (abs(zscore) - absmin_z) / (absmax_z - absmin_z)
    b = 40.0
    a = 1.0 / (1 - np.exp(-b))
    scaled_zscore = a - a * np.exp(-b * normed_zscore)
    r = str(int(start_color[0] + (end_color[0] - start_color[0]) * scaled_zscore))
    g = str(int(start_color[1] + (end_color[1] - start_color[1]) * scaled_zscore))
    b = str(int(start_color[2] + (end_color[2] - start_color[2]) * scaled_zscore))
    if scaled_zscore == 0:
        return 'white'
    return f'rgb({r},{g},{b})'


latex_table_header = r"""\begin{table}
\centering
\begin{tabular}{lrlrlrlrlrl}\toprule
& \multicolumn{6}{c}{$\theta, \varphi$} & \multicolumn{2}{c}{$t$} & \multicolumn{2}{c}{$g$} \\\cmidrule(lr){2-7}\cmidrule(lr){8-9}\cmidrule(lr){10-11}
Weighting Method & & $\rho^0_{00}$ & & $\rho^0_{1,-1}$ & & $\Re[\rho^0_{10}]$ & & $\tau$ & & $\sigma$ \\ \midrule"""

latex_table_footer = r"""\end{{tabular}}
\caption{{Absolute mean pull of each parameter over ${}$ independent simulations (smaller numbers are better). The five best results for a particular variable are labeled.}}
\label{{table:abs_mean_pull}}
\end{{table}}"""


if __name__ == '__main__':
    args = docopt(__doc__)
    fit_file = Path(args['<tsv>']).resolve()
    t = pd.read_table(fit_file)
    t = t[t['Valid']]
    total_iterations = len(t.groupby('Iteration'))
    t = t[
        [
            col
            for col in t.columns
            if 'Error' not in col and 'Iteration' not in col and 'Valid' not in col
        ]
    ]
    truth = t.iloc[0]
    t = t.iloc[1:]

    def f_diff(row):
        return row[1:] - truth[1:]

    def f_abs(x):
        if isinstance(x, (int, float)):
            return abs(x)
        else:
            return x

    t.iloc[:, 1:] = t.apply(f_diff, axis=1)
    m_diff = t.groupby('Method')
    m_absdiff = t.map(f_abs).groupby('Method')
    mean = m_absdiff.mean()
    sigma = m_diff.std()  # = std(x) = std(x-mu)
    z = mean / sigma
    out = z[[col for col in z.columns if 'Method' not in col]]
    index_order = [
        'No Weights Analysis',
        'Sideband Subtraction Analysis',
        'InPlot Analysis',
        'Q-Factor Analysis',
        'Q-Factor Analysis (with t)',
        'Q-Factor Analysis (with g)',
        'Q-Factor Analysis (with t & g)',
        'sPlot Analysis',
        'sQ-Factor Analysis',
        'sQ-Factor Analysis (with t)',
        'sQ-Factor Analysis (with g)',
        'sQ-Factor Analysis (with t & g)',
    ]
    column_labels = {
        'p00': r'$\rho^0_{00}$',
        'p1n1': r'$\rho^0_{1,-1}$',
        'p10': r'$\Re[\rho^0_{10}]$',
        'tau_sig': r'$\tau$',
        'sigma_sig': r'$\sigma$',
    }
    column_order = list(column_labels.keys())
    colors = [
        r'\cellcolor{blue!60}',
        r'\cellcolor{blue!50}',
        r'\cellcolor{blue!40}',
        r'\cellcolor{blue!30}',
        r'\cellcolor{blue!20}',
        r'\cellcolor{blue!10}',
        r'\cellcolor{red!10}',
        r'\cellcolor{red!20}',
        r'\cellcolor{red!30}',
        r'\cellcolor{red!40}',
        r'\cellcolor{red!50}',
        r'\cellcolor{red!60}',
    ]
    out = out.reindex(index=index_order)
    tab = Table()
    tab.add_column(f'Method ({total_iterations}x)')
    for col in column_order:
        tab.add_column(col)
    console.print(latex_table_header)
    for ind, method in enumerate(index_order):
        rich_row = []
        out_row = out.loc[method]
        method_name = str(method).replace(' Analysis', '').replace('&', 'and')
        console.print(f'{method_name}', end='')
        for col in column_order:
            absmin_z = out[col].abs().min()
            absmax_z = out[col].abs().max()
            out[f'Rank {method}'] = out[col].rank()
            rank = int(out[f'Rank {method}'].loc[method])
            rank_str = colors[rank - 1] + ('' if rank > 5 else f'{rank}.')
            val_str = colors[rank - 1] + f'${out_row[col]:.3f}$'
            color_str = zscore_to_colorstr(out_row[col], absmin_z, absmax_z)
            if abs(out_row[col]) == absmin_z:
                color_str += ' bold'
            rich_row += [f'[{color_str}]{out_row[col]:.3f}[/]']
            console.print(f' & {rank_str} & {val_str}', end='')
        tab.add_row(method_name, *rich_row, end_section=(ind == 1 or ind == 6))
        if ind == 1 or ind == 6:
            console.print(r' \\ \cmidrule{2-11}')
        elif ind == 11:
            console.print(r' \\ \bottomrule')
        else:
            console.print(r' \\')
    console.print(latex_table_footer.format(total_iterations))
    console.print(tab)

    def plot_pull(axis, method: str, var: str):
        sig = t.iloc[m_diff.indices.get(method)][var].std()
        data = t.iloc[m_diff.indices.get(method)][var].to_numpy()
        range_max = 3.0
        axis.set_title(method.replace(' Analysis', '').replace('&', 'and'))
        if np.abs(avg := np.mean(data) / sig) > range_max:
            # poor fit
            axis.axvline(0, color='k', lw=3)
            axis.axvline(avg, color='k', ls=':', lw=3, label='mean')
            axis.hist(
                data / sig,
                bins='auto',
                color=RED,
                label='pull',
            )
            axis.legend(loc='upper right')
            # inset = axis.inset_axes([0.4, 0.5, 0.3, 0.3])
            # inset.hist(data / sig, bins='auto', range=(avg - range_max, avg + range_max), color=RED)
            # inset.set_xlim(avg - range_max, avg + range_max)
        else:
            # good fit
            axis.axvline(0, color='k', lw=3)
            axis.axvline(avg, color='k', ls=':', lw=3, label='mean')
            axis.hist(
                data / sig,
                bins='auto',
                range=(avg - range_max, avg + range_max),
                color=BLUE,
                label='pull',
            )
            axis.legend(loc='upper right')
            axis.set_xlim(-range_max, range_max)

    if args['--plot']:
        for col, title in column_labels.items():
            fig, ax = plt.subplot_mosaic("""ABCH\nDEFG\nIJKL""", figsize=(16, 9))
            fig.suptitle(f'Pull Distributions for {title}')
            plots = {
                'A': 'No Weights Analysis',
                'B': 'Sideband Subtraction Analysis',
                'C': 'InPlot Analysis',
                'D': 'Q-Factor Analysis',
                'E': 'Q-Factor Analysis (with t)',
                'F': 'Q-Factor Analysis (with g)',
                'G': 'Q-Factor Analysis (with t & g)',
                'H': 'sPlot Analysis',
                'I': 'sQ-Factor Analysis',
                'J': 'sQ-Factor Analysis (with t)',
                'K': 'sQ-Factor Analysis (with g)',
                'L': 'sQ-Factor Analysis (with t & g)',
            }
            for axis_id, method in plots.items():
                plot_pull(
                    ax[axis_id],
                    var=col,
                    method=method,
                )
            plt.tight_layout()
            plt.savefig(fit_file.parent / f'{col}_pull.png', dpi=300)
